<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-H1EZT1Q9H0"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-H1EZT1Q9H0');
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Peruse - A1</title>
    <link rel="icon" type="image/x-icon" href="../Images/Icon_Large_m.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/peruse.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <link   rel="stylesheet"   href="https://cdn.jsdelivr.net/gh/lipis/flag-icons@7.2.3/css/flag-icons.min.css" 
/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

    <main class="parent">
        <div class="child">
            <div class="Longread-ArticleA"></div>
        </div>

        <div class="child">
            <div class="Article-Header-ImageA"></div>
        </div>
        <div class="child">
            <header class="header">
                <a href="../html/peruse.html">
                    <img src="../Images/Peruse/PERUSE.png" alt="Peruse Logo" class="logo">
                </a>
                
            </header>
        
            <div class="topnav">
                <div id="myLinks">
                    <a href="#news" id="toggle-visibility"><h3>Unhide</h3></a>
                    <a href="#contact"><h3>Contact</h3></a>
                    <a href="#about"><h3>About</h3></a>
                </div>
            </div>
        </div>
        <div class="child">
            <div class="Longread-Content">
                <div class="metabubbles2">
                    <span class="tag2 culture">cultuur</span>
                    <span class="tag2 feature2">
                        <img src="../Images/Peruse/Map.png" alt="">
                    </span>
                </div>
                <div class="Longread-Title">
                <h2>Nieuwe hype onder jongeren: Indonesisch energiepoeder</h2>
                <div class="Longread-SubTitle">
                <p>Poeder dat je energie geeft en dat door je biertje kan: Extra Joss verovert Nederlandse studentenfeestjes. Importeur Thomas Groot ziet de verkoop van het Indonesische energiepoeder jaarlijks met 50% toenemen. Het gebruik lijkt onschuldig, toch schuilen er risico’s, zeggen experts.</p>
              </div>
            </div>
                <div class="parent-container">
                  <div class="Longread-meta">
                    <h4>3 min duur</h4>
                    <p>22 April, 2025</p>
                  </div>
                
                  <div class="SettingsButtons"> 
                    <button id="aa-button" class="rating-button compact">
                      <span id="aa-label"><h4>Aa</h4></span>
                      <input type="range" min="0" max="30" value="10" step="10" class="rating-slider visible form-range" id="aa-slider">
                    </button>
                  </div>
                 </div>
            <br><hr />
            <div class="Main-Longread">
                <div class="Longread-Header"></div>
                <p id="article-text">‘Het gaat eigenlijk goed door elk drankje. Je gooit het in je glas bier of zelfs in de rode wijn’, zegt de Amsterdamse student Martijn Jaartsveld. ‘Vooral aan het eind van de avond wanneer je een beetje inkakt.’ Maar ook ’s ochtends vroeg ideaal om op een brakke dag toch te kunnen studeren. 'Iedereen in mijn omgeving kent het en gebruikt het eigenlijk. Ook omdat ik het ze aanraad.’ 

                  <br><br>
                  Extra Joss-poeder smaakt naar ananas en geeft energie omdat er cafeïne en ginsengextract in zitten. Het gaat om 50 mg cafeïne per zakje, vergelijkbaar met een kopje koffie. Ginseng is een kruid dat ook energieverhogend werkt. Daarnaast bevat het verschillende vitamines B en mierzoete kunstmatige zoetstoffen. <br><br>
                
                  Met bijnamen als ‘legale cocaïne’ of ‘jos kindersos’ — sos is straattaal voor cocaïne — is Extra Joss populair onder jongeren. Naast de energieboost die je ervan krijgt, zit het succes ervan voornamelijk in het gebruiksgemak en de lage prijs.
<br><br>
                
In de webshop van ondernemer Thomas Groot (35) kosten dertig zakjes €14,99 en voor 120 zakjes betaal je €39,99. Hij importeert het poeder sinds 2018 vanuit Indonesië. Daar is Extra Joss sinds kort het officiële energiepoeder van het nationale voetbalteam. ‘Het voordeel is dat er al wat merkbekendheid was, veel studenten kennen het van het backpacken in Zuidoost-Azië.’
Groot is de enige officiële importeur van Extra Joss in Nederland. ‘Mijn eerste klanten waren de après-skibars in Val Thorens.’ <br><br>
                </p>

                <div class="Longform-Image Image1">
                </div>
                <div class="Imagebijschrift">
                  <p>Zakjes Extra Joss in het schap van een supermarkt.</p>
                </div>

                  <br>
                    
                  
                    
                    

                     

                           <h4>Geen script</h4>
                        
                  <p id="article-text">
                    Inmiddels heeft hij dus die webshop en verkoopt hij in nog fysieke winkels in Nederland, waaronder vijftien supermarkten. Hij zegt vorig jaar een recordaantal van een miljoen zakjes te hebben verkocht. Groot zegt afgelopen jaar een omzet van zo’n €200.000 te hebben gedraaid. Over de winst deelt hij geen cijfers, wel geeft hij aan dat de import een grote kostenpost is. <br><br>
    
                    Ervan leven lukt nog niet, alhoewel hij de afzet elk jaar met zo’n 50% ziet toenemen. Naast zijn bedrijf werkt Groot als e-commercemanager bij Stichd, dochterbedrijf van sportmerk Puma. Dat vindt hij een prima combinatie, want wat hij leert over digitale marketing via Extra Joss, zet hij in voor zijn baan. <br><br>      </p>            
                          
                    <h4>Carnaval en gala’s</h4>
                        
                          <p id="article-text">
                            Hoe promoot Groot Extra Joss? ‘In de aanloop naar carnaval heb ik een week lang TikTok-video’s geplaatst in carnavalsthema.’ De omzet lag rond die periode in Brabant zo’n vijf keer hoger dan buiten het carnavalseizoen. Ook Koningsdag, oud en nieuw en studentenfeesten zoals het driedaagse festival Kriminele in Delft zijn belangrijke feestdagen voor zijn handel.’<br><br>
                    
                            Voor marketing zet Groot daarnaast in op studentenverenigingen. Hij zegt met bijna alle Nederlandse verenigingen een samenwerking te hebben. ‘Besturen van studentenverenigingen willen het niet van mij kopen om elke associatie met wit poeder te vermijden.’ Daarom geeft hij het gratis en belandt het in 'goodiebags' op studentengala’s. ‘Uiteindelijk bestellen mensen dan zelf online.’  <br><br> 
                            
                            Het valt Groot op dat drugs in Nederland tegenwoordig niet echt meer een taboe zijn. ‘Studenten vragen me daarom weleens of je Extra Joss kunt snuiven. Dat is niet de bedoeling, je moet het drinken. Het schijnt onwijs te branden in je neus.’ Dat het wit poeder is waar je een energieboost van krijgt, wekt logischerwijs de associatie met harddrugs. Maar de effecten ervan zijn niet te vergelijken en het is legaal. <br><br>
                  </p>

              

                  <h4>‘Niemand naar de kliniek’</h4>
    
                  <p id="article-text">‘Terwijl Red Bull en andere energiedranken minder populair worden, wint dit product terrein, vooral onder mensen die echt hard willen gaan’, ziet Paul Jansen van de Afkickkliniekwijzer. Afkickkliniekwijzer is een van de weinige internetpagina’s die iets over de werking en mogelijke voordelen of gevaren in kaart brengt. <br><br>

                    Het middel is relatief onschuldig, zegt Jansen. ‘Maar het gevaar is dat je veel langer door kunt en meer gaat drinken.’ Vooral jongeren, die gevoeliger zijn voor cafeïne en ‘snel over hun grens’ kunnen gaan. Te veel cafeïne kan leiden tot rusteloosheid, slapeloosheid en trillen. Bij een zeer grote hoeveelheid kan het tot cafeïnevergiftiging leiden. Dit komt vaker voor bij energiedrank dan bij koffie. <br><br>
                      
                    Is Extra Joss verslavend? ‘Verslaving is mogelijk’, zegt Jansen, ‘maar vergelijkbaar met cafeïne. Er gaat niemand voor naar de kliniek.’ <br><br>
                      
                    Het advies vanuit het merk Extra Joss is maximaal twee zakjes per dag. Blijft het daar in de praktijk bij? Nee, ‘er zijn soms wel gekken die tien zakjes op een avond drinken’, klinkt het onder studenten. Jaartsveld: ‘Ik denk dat de Nederlandse importeur hier héél goed aan verdient.’ <br><br> </p>

                    
                    
                <br><br>

             
            </div>

            

            <br><br><br><br>

     

        </div>
        </div>
        
      </main>

      <div class="Rating"> 
        <h3>Beoordeling van geloofwaardigheid</h3>
        <p id="article-text">
          De mate waarin je dit artikel als geloofwaardig hebt ervaren, op een schaal van 1 tot 100.
        </p><br>
        <div class="schaalinfo">
          <p id="info-links">helemaal niet geloofwaardig</p>
          <p id="info-rechts">zeer geloofwaardig</p>
        </div>
        <br>
        <div class="Range_container">
          <div class="range-slider">
            <div id="slider_thumb" class="range-slider_thumb"></div>
            <div class="range-slider_line">
              <div id="slider_line" class="range-slider_line-fill"></div>
            </div>
            <input id="slider_input" class="range-slider_input" type="range" value="50" min="0" max="100">
          </div>
        </div>
        <div class="container">
          <button id="submitBtn" class="btn inactive">Verstuur</button>
        </div>
      </div>


   

        <footer class="footer">
            <div id="back-to-top" class="footerdiv">
                <div class="scrollwatcher"></div>
                <br>
            </div>
        </footer>
    

        <script type="module">

import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm";

// Initialize Supabase client
const supabaseUrl = 'https://rgoydwojepkjbqzdldft.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJnb3lkd29qZXBramJxemRsZGZ0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzk3MTMyMTYsImV4cCI6MjA1NTI4OTIxNn0.gjk1wM4DUaxAQV9H3zK3hzktav-Pjo40fEIDHR7DTWQ';
const supabaseClient = createClient(supabaseUrl, supabaseKey);

// User ID management functions
function getUserIdFromLocalStorage() {
  return localStorage.getItem("userId");
}
function isUserIdInLocalStorage() {
  return !!getUserIdFromLocalStorage();
}
function generateUUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    const r = (Math.random() * 16) | 0,
          v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}
function setUserIdInLocalStorage() {
  const newId = generateUUID();
  console.log("Generated UserID:", newId);
  localStorage.setItem("userId", newId);
}
if (!isUserIdInLocalStorage()) {
  setUserIdInLocalStorage();
}

async function insertScriptieVertrouwen(sliderValue, timeSpent) {
  const submitDate = new Date().toISOString();
  
  const { data, error } = await supabaseClient
    .from("scriptie_vertrouwen")
    .insert([{
      slider_values: sliderValue,
      article_number: "B",  // Force article number to always be "B"
      user_id: getUserIdFromLocalStorage(),
      time_spent: timeSpent,
      submit_date: submitDate
    }]);
    
  if (error) {
    console.error("Error inserting into scriptie_vertrouwen:", error);
  } else {
    console.log("Successfully inserted into scriptie_vertrouwen:", data);
  }
}

// Wait for the DOM to fully load
document.addEventListener("DOMContentLoaded", function () {
  // Record page load time (in milliseconds)
  const pageLoadTime = Date.now();

  // === New Slider Functionality ===
  const slider_input = document.getElementById("slider_input");
  const slider_thumb = document.getElementById("slider_thumb");
  const slider_line = document.getElementById("slider_line");
  const submitBtn = document.getElementById("submitBtn");
  let sliderChanged = false; // Initially, the slider has not been changed

  function showSliderValue() {
    slider_thumb.innerHTML = slider_input.value;
    const bulletPosition = slider_input.value / slider_input.max;
    const space = slider_input.offsetWidth - slider_thumb.offsetWidth;
    slider_thumb.style.left = (bulletPosition * space) + 'px';
    slider_line.style.width = slider_input.value + '%';
  }
  // Call once to set up initial position (without marking as changed)
  showSliderValue();
  window.addEventListener("resize", showSliderValue);
  slider_input.addEventListener('input', () => {
    showSliderValue();
    if (!sliderChanged) {
      sliderChanged = true;
      submitBtn.classList.remove("inactive");
      submitBtn.classList.add("active");
    }
  }, false);

  // === Submit Button, Confirmation, Animation & Redirect ===
  submitBtn.addEventListener("click", async () => {
    if (!sliderChanged) {
      const proceed = confirm("You have not changed the slider value from its default. Do you want to submit this number?");
      if (!proceed) {
        return;
      }
    }

    const sliderValue = Number(slider_input.value);
    const timeSpent = Math.floor((Date.now() - pageLoadTime) / 1000);

    console.log("Submit clicked. Slider value:", sliderValue, "Time spent (s):", timeSpent);

    // Store the article read state and score in localStorage
  // Retrieve the correct A article ID
const aOptions = ["A1", "A2", "A3", "A4"];
const selectedAIndex = parseInt(localStorage.getItem("selectedAOption"), 10);
const selectedA = aOptions[selectedAIndex];

// Store the article read state and score in localStorage using the correct key
const articleKey = `article_${selectedA}_read`;
const scoreKey = `article_${selectedA}_score`;

    localStorage.setItem(articleKey, "true");
    localStorage.setItem(scoreKey, sliderValue);

    // Insert data into Supabase with "B" as the article number
    await insertScriptieVertrouwen(sliderValue, timeSpent);

    // Disable the button to prevent duplicate clicks and trigger animation
    submitBtn.disabled = true;
    $(submitBtn).addClass('btn-progress');
    setTimeout(() => {
      $(submitBtn).addClass('btn-fill');
    }, 500);
    setTimeout(() => {
      $(submitBtn).removeClass('btn-fill').addClass('btn-complete');
    }, 4100);

    // Redirect to the main page after submission and animation
    setTimeout(() => {
      window.location.href = "../html/peruse.html";
    }, 4100);
  });

  // === Article Visibility & Toggle ===
  const options = ["A1", "A2", "A3", "A4", "B1", "B2"];
  const storageKey = "selectedAOption";
  let selectedOptionIndex = localStorage.getItem(storageKey);

  if (selectedOptionIndex === null) {
    selectedOptionIndex = Math.floor(Math.random() * options.length);
    localStorage.setItem(storageKey, selectedOptionIndex);
  } else {
    selectedOptionIndex = Number(selectedOptionIndex);
  }

  const selectedOption = options[selectedOptionIndex];
  const selectedElement = document.getElementById(selectedOption);
  if (selectedElement) {
    selectedElement.classList.remove("hidden");
    selectedElement.classList.add("visible");
  } else {
    console.error(`Element with id "${selectedOption}" not found.`);
  }

  const article = document.querySelector(".Longread-ArticleA");
if (article) {
  window.addEventListener("scroll", function () {
    const scrollY = window.scrollY;
    const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
    const fadeStart = maxScroll * 0.3;
    const fadeEnd = maxScroll * 0.5;

    if (scrollY >= fadeStart && scrollY <= fadeEnd) {
      let progress = (scrollY - fadeStart) / (fadeEnd - fadeStart);
      let r = Math.round(69 * (1 - progress));
      let g = Math.round(18 * (1 - progress));
      let b = Math.round(18 * (1 - progress));
      article.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
    } else if (scrollY > fadeEnd) {
      article.style.backgroundColor = "#000000";
    } else {
      article.style.backgroundColor = "#451212";
    }
  });
} else {
  console.error("Element with class 'Longread-ArticleA' not found.");
}
          
              // === Scroll Watcher Progress Bar ===
              const toggleVisibilityClass = (element, visibleClass) => {
  const isScrollable = document.body.scrollHeight > window.innerHeight;
  const isScrolled = window.scrollY > 0;
  if (isScrollable && isScrolled) {
    element.classList.add(visibleClass);
  } else {
    element.classList.remove(visibleClass);
  }
};

// === Scroll Progress Bar ===
const scrollWatcher = document.querySelector('.scrollwatcher');
if (scrollWatcher) {
  window.addEventListener('scroll', () => {
    const scrollTop = window.scrollY;
    const docHeight = document.documentElement.scrollHeight - window.innerHeight;
    const progress = Math.min(scrollTop / docHeight, 1);
    scrollWatcher.style.transform = `scaleX(${progress})`;
  });
} else {
  console.error("Element with class 'scrollwatcher' not found.");
}

// === Back-to-Top Button ===
const backToTopButton = document.getElementById("back-to-top");
if (backToTopButton) {
  const updateBackToTopVisibility = () => {
    toggleVisibilityClass(backToTopButton, "visible");
  };

  backToTopButton.addEventListener("click", () => {
    window.scrollTo({ top: 0, behavior: "smooth" });
  });

  window.addEventListener("scroll", updateBackToTopVisibility);
  window.addEventListener("resize", updateBackToTopVisibility);
  updateBackToTopVisibility();
} else {
  console.error("Back-to-top element not found.");
}

// === Footer bar or scroll element ===
const footerBar = document.getElementById("footer-bar"); // or .querySelector('.your-class')
if (footerBar) {
  const updateFooterVisibility = () => {
    toggleVisibilityClass(footerBar, "visiblefooter");
  };

  window.addEventListener("scroll", updateFooterVisibility);
  window.addEventListener("resize", updateFooterVisibility);
  updateFooterVisibility();
}
          
              // === Mobile Menu Toggle ===
              const menuToggle = document.getElementById("menu-toggle");
              if (menuToggle) {
                menuToggle.addEventListener("click", function(){
                  const links = document.getElementById("myLinks");
                  if (links) {
                    links.style.display = links.style.display === "block" ? "none" : "block";
                  } else {
                    console.error("Element with id 'myLinks' not found.");
                  }
                });
              }
          
              // === Adjust Widths for .scroll divs ===
              document.querySelectorAll('.scroll div').forEach(div => {
                const contentWidth = Array.from(div.children).reduce((total, child) => total + child.offsetWidth + 20, 0);
                div.style.width = `${contentWidth}px`;
              });
            });

            const slider_input = document.getElementById('slider_input'),
      slider_thumb = document.getElementById('slider_thumb'),
      slider_line = document.getElementById('slider_line');

function showSliderValue() {
  slider_thumb.innerHTML = slider_input.value;
  const bulletPosition = (slider_input.value /slider_input.max),
        space = slider_input.offsetWidth - slider_thumb.offsetWidth;

  slider_thumb.style.left = (bulletPosition * space) + 'px';
  slider_line.style.width = slider_input.value + '%';
}

showSliderValue();
window.addEventListener("resize",showSliderValue);
slider_input.addEventListener('input', showSliderValue, false);

document.addEventListener('DOMContentLoaded', function () {

const button = document.getElementById('aa-button');
const label = document.getElementById('aa-label'); // Although not used in logic, keep if needed elsewhere
const slider = document.getElementById('aa-slider');

// Key for storing the slider value in localStorage
const storageKey = 'userFontSizeSliderValue';

// Font size values corresponding to the slider steps
const fontSizes = [14, 18, 22, 28]; // 4 sizes for the 4 steps (0, 10, 20, 30)

// To store whether the button is expanded or not
let expanded = false;

// --- Helper Functions ---

// Function to apply the font size based on the slider value
function applyFontSize(sliderValue) {
    // Ensure sliderValue is treated as a number
    const value = parseInt(sliderValue, 10);
    // Calculate index, ensuring it's within bounds
    const index = Math.min(Math.max(value / 10, 0), fontSizes.length - 1);
    const fontSize = fontSizes[index];

    // Apply this font size to all relevant <p> elements
    // Note: IDs should be unique. If you have multiple paragraphs, consider using a class instead, e.g., '.article-text'
    const articleTextElements = document.querySelectorAll('#article-text');
    articleTextElements.forEach(p => {
        p.style.fontSize = `${fontSize}px`;
    });

    // Ensure the slider visually matches the applied value
    slider.value = value;
}

// Function to save the current slider value to localStorage
function saveSetting() {
    localStorage.setItem(storageKey, slider.value);
}

// Function to load the setting from localStorage and apply it
function loadAndApplySetting() {
    const savedValue = localStorage.getItem(storageKey);
    let initialSliderValue;

    // Check if a value was found in localStorage
    if (savedValue !== null) {
        initialSliderValue = parseInt(savedValue, 10);
        // Basic validation: ensure it's a number within the slider's range and steps
        if (isNaN(initialSliderValue) || initialSliderValue < slider.min || initialSliderValue > slider.max || initialSliderValue % slider.step !== 0) {
            console.warn('Invalid font size value found in localStorage. Using default.');
            initialSliderValue = 10; // Use default (matches HTML value="10")
            localStorage.removeItem(storageKey); // Optional: Remove the invalid value
        }
    } else {
        // No saved value, use the default from the HTML slider element
        initialSliderValue = parseInt(slider.value, 10); // Default is 10 based on your HTML
    }

    // Apply the loaded or default font size
    applyFontSize(initialSliderValue);
}

// --- Event Listeners ---

button.addEventListener('click', function () {
    // Toggle visibility of the slider
    if (!expanded) {
        slider.classList.remove('hidden'); // Assuming you have CSS rules for .hidden
        button.classList.remove('compact'); // Assuming you have CSS rules for .compact
        expanded = true;
    } else {
        slider.classList.add('hidden');
        button.classList.add('compact');
        expanded = false;
    }
    // Ensure initial state of slider visibility matches 'expanded' status if needed
    // e.g., if slider starts hidden:
    // if (!expanded) slider.classList.add('hidden');
});

slider.addEventListener('input', function () {
    // Apply the font size based on the current slider value
    applyFontSize(this.value);
    // Save the new setting to localStorage immediately
    saveSetting();
});

// --- Initialization ---

// Load the saved setting (or default) when the page loads
loadAndApplySetting();

// Initial setup for button/slider visibility (assuming it starts compact and hidden)
if (!expanded) {
    slider.classList.add('hidden');
    button.classList.add('compact');
}

});

document.addEventListener('DOMContentLoaded', () => {
    // --- Element Selection ---
    const numberElement = document.getElementById('countup-number');
    const orderButton = document.getElementById('order-button');

    // Check if elements exist
    if (!numberElement) {
        console.error('Element with ID "countup-number" not found.');
        return;
    }
    if (!orderButton) {
        console.error('Element with ID "order-button" not found.');
        // return; // Or allow script to continue without button features
    }

    // --- Animation State ---
    let currentAnimationFrameId = null;

    // --- Reusable Animation Function (Keep as is) ---
    function animateCounter(element, targetValue, duration) {
        if (currentAnimationFrameId) {
            cancelAnimationFrame(currentAnimationFrameId);
        }
        let startValue = 0;
        let startTime = null;
        const currentText = element.textContent || '';
        const cleanedText = currentText.replace(/€|\s/g, '').replace(/\./g, '').replace(',', '.');
        const parsedValue = parseFloat(cleanedText);
        if (!isNaN(parsedValue)) {
            startValue = parsedValue;
        } else {
            console.warn(`Could not parse number from "${currentText}", starting from 0.`);
        }

        function easeInCubic(t) { return t * t * t; }

        const step = (timestamp) => {
            if (!startTime) startTime = timestamp;
            const elapsedTime = timestamp - startTime;
            let progress = Math.min(elapsedTime / duration, 1);
            const easedProgress = easeInCubic(progress);
            const currentValue = startValue + (targetValue - startValue) * easedProgress;
            element.textContent = `€${Math.ceil(currentValue).toLocaleString('nl-NL', { maximumFractionDigits: 0 })}`;
            if (progress < 1) {
                currentAnimationFrameId = requestAnimationFrame(step);
            } else {
                element.textContent = `€${targetValue.toLocaleString('nl-NL', { maximumFractionDigits: 0 })}`;
                currentAnimationFrameId = null;
                startTime = null;
            }
        };
        currentAnimationFrameId = requestAnimationFrame(step);
    }

    // --- Intersection Observer for Initial Animation (Keep as is) ---
    const observerOptions = {
        root: null,
        rootMargin: "-40% 0px -40% 0px",
        threshold: 0
    };
    const startAnimationCallback = (entries, observer) => {
        entries.forEach(entry => {
             // Using currentAnimationFrameId === null as a simple flag to run once
            if (entry.isIntersecting && currentAnimationFrameId === null && !numberElement.dataset.initialAnimationDone) {
                 const initialTarget = parseInt(numberElement.getAttribute('data-target'), 10) || 1000;
                 const initialDuration = 2000;
                 animateCounter(numberElement, initialTarget, initialDuration);
                 numberElement.dataset.initialAnimationDone = 'true'; // Set flag on number element
                 observer.unobserve(entry.target);
            }
        });
    };
    const observer = new IntersectionObserver(startAnimationCallback, observerOptions);
    if(numberElement){ // Observe only if element exists
        observer.observe(numberElement);
    }


    // --- Button Click Listener (MODIFIED) ---
    if(orderButton) { // Add listener only if button exists
        orderButton.addEventListener('click', () => {
            // Existing values (Note: Target changed in your provided code)
            const newTarget = 15605; // Using the value from your latest code snippet
            const clickDuration = 2500;

            console.log("Order button clicked, scrolling, animating and updating style."); // Updated log

            // ***** ADD THIS SECTION *****
            // --- Scroll to Teleport Target ---
            const teleportTarget = document.getElementById('teleport');
            if (teleportTarget) {
                teleportTarget.scrollIntoView({
                    behavior: 'smooth', // Smooth scroll
                    block: 'start'      // Align target's top with viewport's top
                });
            } else {
                console.warn('Element with id="teleport" not found for scrolling.');
            }
            // --- End Scroll ---
            // ***** END OF ADDED SECTION *****


            // 1. Trigger the number animation (Existing)
            animateCounter(numberElement, newTarget, clickDuration);

            // --- Style and State Updates for Button (Existing) ---
            // 2. Change button color class
            orderButton.classList.remove('btn-primary'); // Remove blue
            orderButton.classList.add('btn-success');   // Add green

            // 3. Change button text
            orderButton.textContent = 'Gereserveerd';

            // 4. Disable the button
            orderButton.disabled = true;
            // --- End Style Updates ---
        });
    }

}); 

document.addEventListener('DOMContentLoaded', function() {
    const mapElement = document.getElementById('map');
    if (mapElement) {
        const amsterdamCoords = [52.372, 4.894];
        const initialZoom = 13;
        const map = L.map('map').setView(amsterdamCoords, initialZoom);

        // --- MODIFIED: Use CartoDB Dark Matter Tile Layer (Free) ---
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            // Update attribution for CartoDB and OpenStreetMap
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd', // Standard for CartoDB tiles
            maxZoom: 19 // CartoDB's typical max zoom level
        }).addTo(map);
        // --- END MODIFIED ---


        // --- Hotel Data (Keep as before) ---
        const hotelData = [ /* ... Your hotel data array ... */
            { name: "Amstel Hotel", lat: 52.359984, lng: 4.905243, category: "Voor 1980" },
            { name: "Hotel De L'Europe", lat: 52.367644, lng: 4.894466, category: "Voor 1980" },
            { name: "Doelen Hotel", lat: 52.36825, lng: 4.895859, category: "Voor 1980" },
            { name: "Grand Hotel Krasnapolsky", lat: 52.372729, lng: 4.894385, category: "Voor 1980" },
            { name: "Hilton Hotel", lat: 52.35143, lng: 4.872012, category: "Voor 1980" },
            { name: "Pulitzer Amsterdam", lat: 52.372823, lng: 4.883399, category: "Voor 1980" },
            { name: "Hotel Okura Amsterdam", lat: 52.348585, lng: 4.893625, category: "Voor 1980" },
            { name: "Marriott Hotel", lat: 52.362549, lng: 4.880125, category: "Voor 1980" },
            { name: "Renaissance Hotel", lat: 52.378156, lng: 4.894397, category: "Voor 1980" },
            { name: "Garden Hotel", lat: 52.35118, lng: 4.874002, category: "1980-2010" },
            { name: "Barbizon Palace", lat: 52.376486, lng: 4.900472, category: "1980-2010" },
            { name: "The Grand", lat: 52.370945, lng: 4.895604, category: "1980-2010" },
            { name: "Hotel 717", lat: 52.364791, lng: 4.885341, category: "1980-2010" },
            { name: "The Dylan Amsterdam", lat: 52.369279, lng: 4.883983, category: "1980-2010" },
            { name: "The College Hotel", lat: 52.352776, lng: 4.883686, category: "1980-2010" },
            { name: "Grand Hotel Amrâth Amsterdam", lat: 52.374647, lng: 4.903879, category: "1980-2010" },
            { name: "Conservatorium Hotel", lat: 52.358605, lng: 4.878526, category: "Vanaf 2010" },
            { name: "Andaz Amsterdam Prinsengracht", lat: 52.367908, lng: 4.882883, category: "Vanaf 2010" },
            { name: "Waldorf Astoria", lat: 52.364671, lng: 4.89694, category: "Vanaf 2010" },
            { name: "W Amsterdam", lat: 52.3728, lng: 4.889758, category: "Vanaf 2010" },
            { name: "Hotel TwentySeven", lat: 52.37251, lng: 4.893336, category: "Vanaf 2010" },
            { name: "Kimpton De Witt Hotel", lat: 52.377234, lng: 4.895533, category: "Vanaf 2010" },
            { name: "Hyatt Regency Amsterdam Hotel", lat: 52.361778, lng: 4.911721, category: "Vanaf 2010" },
            { name: "Amsterdam Riverside Hotel", lat: 52.353377, lng: 4.907169, category: "Vanaf 2010" },
            { name: "Grand Boutique Hotel Maurits at the Park", lat: 52.362199, lng: 4.91965, category: "Vanaf 2010" },
            { name: "The Diamond Amsterdam", lat: 52.363776, lng: 4.883282, category: "Vanaf 2010" },
            { name: "Rosewood Amsterdam", lat: 52.365751, lng: 4.882848, category: "Vanaf 2010" }
        ];

        // --- Define Colors for Categories (Keep as before) ---
        const categoryColors = { /* ... Your category colors ... */
             "Voor 1980": "#ffbeaa", "1980-2010": "#f05031", "Vanaf 2010": "#dc3545", "default": "#6c757d"
        };
        function getColor(category) { /* ... Your getColor function ... */
             return categoryColors[category] || categoryColors.default;
         }

        // --- Add Markers (Keep lighter border color) ---
        console.log(`Adding ${hotelData.length} hotel markers...`);
        hotelData.forEach(hotel => {
            const lat = parseFloat(hotel.lat);
            const lng = parseFloat(hotel.lng);
            const category = hotel.category;
            // Slightly improved check for valid coordinates and name
            if (hotel.name && typeof lat === 'number' && !isNaN(lat) && typeof lng === 'number' && !isNaN(lng)) {
                const markerOptions = {
                    radius: 7,
                    fillColor: getColor(category),
                    color: "#CCCCCC", // Lighter border color good for dark maps
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.85
                };
                const marker = L.circleMarker([lat, lng], markerOptions).addTo(map);
                marker.bindPopup(`<b>${hotel.name}</b><br><i>${category}</i>`);
            } else {
                 // More specific warning for debugging
                 console.warn(`Skipping hotel due to invalid data: Name=${hotel.name}, Lat=${hotel.lat}, Lng=${hotel.lng}`);
            }
        });

        console.log("Leaflet map initialized with CartoDB dark theme and markers."); // Update log message

    } else {
         // More specific error message
         console.error("Map container element with ID 'map' not found in the DOM.");
    }
});

document.addEventListener('DOMContentLoaded', () => {
    // --- Reveal/Collapse Logic ---
    const trigger = document.getElementById('cdb-trigger'); 
    const content = document.getElementById('cdb-audiovisual');

    if (trigger && content) {
        const toggleContent = () => {
            const isVisible = content.classList.contains('visible');
            if (isVisible) {
                content.classList.remove('visible');
                trigger.classList.remove('active');
                trigger.setAttribute('aria-expanded', 'false');
            } else {
                content.classList.add('visible');
                trigger.classList.add('active');
                trigger.setAttribute('aria-expanded', 'true');
                // Optional: Scroll the content into view slightly after opening
                // setTimeout(() => {
                //    content.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                // }, 700); // Delay matches transition time
            }
        };

        // Click event
        trigger.addEventListener('click', toggleContent);

        // Keyboard event (Enter/Space) for accessibility
        trigger.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault(); // Prevent page scroll on Space
                toggleContent();
            }
        });

    } else {
        console.error("Inline trigger or collapsible content element not found. Check IDs: #cdb-trigger, #cdb-audiovisual");
    }

    // --- Parallax Scroll Logic (Keep from previous step) ---
    const wrapper = content; // Use the 'content' variable which refers to the wrapper
    const parallaxText = wrapper ? wrapper.querySelector('.Parallax_Text') : null;

    if (wrapper && parallaxText) {
        const speedFactor = 1.2; 
        let isTicking = false;

        function updateParallax() {
            // Only run if wrapper is visible
            if (!wrapper.classList.contains('visible')) {
                isTicking = false;
                return; 
            }

            const rect = wrapper.getBoundingClientRect();
             // Avoid calculations if not in viewport
            if (rect.bottom < 0 || rect.top > window.innerHeight) {
                 isTicking = false;
                 return;
            }

            const wrapperHeight = wrapper.offsetHeight;
            const viewportHeight = window.innerHeight;
            const wrapperCenterY = rect.top + wrapperHeight / 2;
            const screenCenterY = viewportHeight / 2;
            const diff = screenCenterY - wrapperCenterY; 
            const translateY = -diff * speedFactor; 

            parallaxText.style.transform = `translateX(-50%) translateY(${translateY}px)`;
            isTicking = false;
        }

        function onScroll() {
            if (!isTicking) {
                window.requestAnimationFrame(updateParallax);
                isTicking = true;
            }
        }

        window.addEventListener('scroll', onScroll);
        window.addEventListener('resize', () => {
           if (!isTicking) {
               window.requestAnimationFrame(updateParallax);
               isTicking = true;
           }
        });
    } else {
         console.error("Parallax elements not found within #cdb-audiovisual.");
    }
});

document.addEventListener('DOMContentLoaded', () => {

const animatedImages = document.querySelectorAll('.HandImage-Left img, .HandImage-Right img');

if (animatedImages.length === 0) {
    console.warn("No elements found for scroll animation with selectors '.HandImage-Left img, .HandImage-Right img'");
    return;
}

let isTicking = false;

function handleScrollAnimations() {
    if (!isTicking) {
        window.requestAnimationFrame(() => {
            const vh = window.innerHeight;

            animatedImages.forEach(image => {
                const rect = image.getBoundingClientRect();
                const elementTop = rect.top;

                // --- Define the Scroll Zone for Animation ---

                // *** MODIFIED START POINT ***
                // Start when the top edge is 90% from the top of the viewport (10% in view)
                const animationStartPoint = vh * 0.9; 
                // *** END MODIFICATION ***

                // End when the top edge reaches the middle of the viewport (remains same)
                const animationEndPoint = vh * 0.5; 
                // Calculate the total distance over which the animation occurs
                const animationDistance = animationStartPoint - animationEndPoint;

                // Calculate progress (0 at start point, 1 at end point)
                let progress = 0;
                 // Prevent division by zero if start/end points overlap or distance is negative
                if (animationDistance > 0) { 
                    const distanceScrolledInZone = animationStartPoint - elementTop;
                    progress = distanceScrolledInZone / animationDistance;
                } else if (elementTop < animationEndPoint) { 
                     // If past the end point, progress is 1
                     progress = 1;
                }

                // Clamp progress between 0 and 1
                progress = Math.max(0, Math.min(1, progress));

                // Calculate Styles based on Progress
                const currentOpacity = progress;
                let startTranslateX = -80; // Default left
                const parentWrapper = image.closest('.Scroll-HandImage');
                if (parentWrapper && parentWrapper.classList.contains('HandImage-Right')) {
                    startTranslateX = 80; // Set positive for right
                }
                const currentTranslateX = startTranslateX * (1 - progress);

                // Apply Styles
                image.style.opacity = currentOpacity;
                image.style.transform = `translateX(${currentTranslateX}%)`;

            }); // End forEach

            isTicking = false;
        }); // End requestAnimationFrame
        isTicking = true;
    }
} // End handleScrollAnimations

// Initial call & Listeners (Keep as before)
handleScrollAnimations();
window.addEventListener('scroll', handleScrollAnimations, { passive: true });
window.addEventListener('resize', handleScrollAnimations, { passive: true });

console.log(`Scroll animations initialized for ${animatedImages.length} elements.`);

// --- Include the rest of your page's JavaScript below ---
// (e.g., number animation, map init, button clicks, font slider etc.)
// Ensure they are correctly placed, likely after the element selections

});

document.addEventListener('DOMContentLoaded', function() {
    // --- Sterren Selector Setup ---
    const ratingContainer = document.getElementById('michelin-rating');
    const stars = ratingContainer.querySelectorAll('.michelin-star');
    const ratingDisplay = document.getElementById('current-rating-display');
    const emptyStarSrc = '../Images/Peruse/Michelin_Empty.png'; // Jouw pad
    const fullStarSrc = '../Images/Peruse/MichelinStar_Full.png'; // Jouw pad
    let currentRating = 1;

    // *** NEW: Flag to track if initial blinking is active ***
    let initialBlinkActive = true;

    // *** NEW: Add blinking class on page load ***
    stars.forEach(star => {
        star.classList.add('blinking-stars');
    });

    function updateStarsVisual(rating) {
        stars.forEach((star, index) => {
            const starValue = index + 1;
            if (starValue <= rating) {
                star.src = fullStarSrc;
                star.alt = `Rating: ${starValue} ster(ren)`;
            } else {
                star.src = emptyStarSrc;
                star.alt = `Rate ${starValue} ster(ren)`;
            }
        });
        if (ratingDisplay) {
            ratingDisplay.textContent = `Aantal Michelin ${rating}-ster restaurants`;
            if (rating === 0) {
                 ratingDisplay.textContent = `Selecteer een sterren-niveau`;
            }
        }
    }

    // --- Chart.js Setup ---
    const ctx = document.getElementById('michelinBarChart').getContext('2d');
    let barChart = null;

    // Note: Updated Dutch labels are used here
    const chartRawData = {
        labels: ['Nederland', 'België', 'Frankrijk', 'Duitsland', 'Verenigd Koninkrijk', 'Zwitserland'],
        datasets: {
            '1': [102, 128, 534, 280, 170, 108],
            '2': [19, 23, 75, 50, 27, 26],
            '3': [1, 2, 30, 10, 9, 4]
        },
        titles: { '1': '', '2': '', '3': '' },
        colors: {
            '1': 'rgba(173, 221, 142, 0.6)', '2': 'rgba(254, 217, 118, 0.6)', '3': 'rgba(228, 26, 28, 0.6)'
        },
        borderColors: {
           '1': 'rgba(173, 221, 142, 1)', '2': 'rgba(254, 217, 118, 1)', '3': 'rgba(228, 26, 28, 1)'
        }
    };

    // Note: flagMap keys need to match chartRawData.labels for flags to show
    // Using English keys here based on previous code. Adjust if needed.
    const flagMap = {
        'Nederland': '🇳🇱',           // Key matches label
        'België': '🇧🇪',              // Key matches label
        'Frankrijk': '🇫🇷',           // Key matches label
        'Duitsland': '🇩🇪',           // Key matches label
        'Verenigd Koninkrijk': '🇬🇧', // Key matches label
        'Zwitserland': '🇨🇭'          // Key matches label
    };
    // If you used English labels before:
    // const flagMap = {
    //     'Netherlands': '🇳🇱', 'Belgium': '🇧🇪', 'France': '🇫🇷',
    //     'Germany': '🇩🇪', 'UK': '🇬🇧', 'Switzerland': '🇨🇭'
    // };


    function renderOrUpdateChart(rating) {
        if (rating < 1 || rating > 3) {
             if (barChart) { barChart.destroy(); barChart = null; }
            return;
        }
        const ratingStr = rating.toString();
        const dataToShow = chartRawData.datasets[ratingStr];
        const titleToShow = chartRawData.titles[ratingStr];
        const colorToShow = chartRawData.colors[ratingStr];
        const borderColorToShow = chartRawData.borderColors[ratingStr];

        const chartOptions = {
            responsive: true, maintainAspectRatio: false,
            plugins: {
                title: { display: true, text: titleToShow, font: { size: 16 } },
                legend: { display: false },
            },
            scales: {
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Aantal Restaurants' }
                },
                x: {
                    // Updated title to use Dutch source text
                    title: { display: true, text: 'bron: Michelin, 2024' },
                    grid: {
                        display: false
                    },
                    ticks: {
                         display: true,
                         color: '#a1a1a1',
                         font: {
                             size: 12,
                             family: "'Noto Color Emoji', 'Segoe UI Emoji', 'Apple Color Emoji', sans-serif"
                         },
                         callback: function(value, index, ticks) {
                            const label = this.getLabelForValue(value); // Gets the label from chartRawData.labels
                            const flag = flagMap[label] || '?'; // Looks up based on that label
                            // console.log(`Tick Callback - Index: ${index}, Label: "${label}", Flag: ${flag}`);
                            return [flag, label];
                        }
                    },
                    afterFit: function(scaleInstance) {
                        scaleInstance.height = scaleInstance.height + 20;
                    }
                }
            }
        };

        if (barChart) {
            barChart.data.datasets[0].data = dataToShow;
            barChart.data.datasets[0].backgroundColor = colorToShow;
            barChart.data.datasets[0].borderColor = borderColorToShow;
            barChart.options.plugins.title.text = titleToShow;
            // Ensure options using the new font are applied on update
            barChart.options.scales.x.ticks.font.family = chartOptions.scales.x.ticks.font.family;
            barChart.options.scales.x.afterFit = chartOptions.scales.x.afterFit; // Re-apply afterFit too
            barChart.options.scales.x.ticks.callback = chartOptions.scales.x.ticks.callback; // Re-apply callback
            barChart.update();
        } else {
            barChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: chartRawData.labels, // Use the Dutch labels here
                    datasets: [{
                        label: 'Aantal Restaurants', data: dataToShow,
                        backgroundColor: colorToShow, borderColor: borderColorToShow, borderWidth: 1
                    }]
                },
                options: chartOptions
            });
        }
    }

    // --- Event Listeners Sterren ---
    stars.forEach(star => {
        star.addEventListener('click', function() {
            // *** NEW: Stop blinking on first click ***
            if (initialBlinkActive) {
                stars.forEach(s => s.classList.remove('blinking-stars')); // Remove from all stars
                initialBlinkActive = false; // Stop blinking permanently
            }

            // --- Original click logic ---
            const clickedValue = parseInt(this.getAttribute('data-value'));
            if (currentRating !== clickedValue) {
                currentRating = clickedValue;
                updateStarsVisual(currentRating);
                renderOrUpdateChart(currentRating);
            }
             // No console log here in original code, removed
        });

        star.addEventListener('mouseover', function() {
             // Original hover logic: Preview rating
             const hoverValue = parseInt(this.getAttribute('data-value'));
             // Temporarily show fill state up to the hovered star (Different from updateStarsVisual)
             stars.forEach((s, index) => {
                 s.src = (index < hoverValue) ? fullStarSrc : emptyStarSrc;
             });
        });

        star.addEventListener('mouseout', function() {
            // Original mouseout logic: Restore visual based on currentRating
            updateStarsVisual(currentRating);
        });
    });

     // --- Initialisatie bij laden ---
     updateStarsVisual(currentRating);
     renderOrUpdateChart(currentRating);

});
 
    </script>

    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.7/dist/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</body>
</html>
