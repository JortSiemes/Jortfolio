<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-H1EZT1Q9H0"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-H1EZT1Q9H0');
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Peruse - A4</title>
    <link rel="icon" type="image/x-icon" href="../Images/Icon_Large_m.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/peruse.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <link   rel="stylesheet"   href="https://cdn.jsdelivr.net/gh/lipis/flag-icons@7.2.3/css/flag-icons.min.css" 
/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

    <main class="parent">
        <div class="child">
            <div class="Longread-ArticleA"></div>
        </div>

        <div class="child">
            <div class="Article-Header-ImageA"></div>
        </div>
        <div class="child">
            <header class="header">
                <a href="../html/peruse.html">
                    <img src="../Images/Peruse/PERUSE.png" alt="Peruse Logo" class="logo">
                </a>
                
            </header>
        
            <div class="topnav">
                <div id="myLinks">
                    <a href="#news" id="toggle-visibility"><h3>Unhide</h3></a>
                    <a href="#contact"><h3>Contact</h3></a>
                    <a href="#about"><h3>About</h3></a>
                </div>
            </div>
        </div>
        <div class="child">
            <div class="Longread-Content">
                <div class="metabubbles2">
                    <span class="tag2 culture">cultuur</span>
                    
                </div>
                <div class="Longread-Title">
                <h2>Vijf sterren is passÃ©: Het Amsterdamse zessterrenhotel</h2>
                <div class="Longread-SubTitle">
                <p>In Amsterdam opent volgende maand het Rosewood Hotel zijn deuren, een zogenoemd zessterrenhotel, dat zich richt op de reiziger die luxe gewend is. Maar wat moeten we ons voorstellen bij zes sterren? Hoe ziet die service eruit? We gingen te rade bij experts in de wereld van de haute hÃ´tellerie.</p>
              </div>
            </div>
                <div class="parent-container">
                  <div class="Longread-meta">
                    <h4>4 min duur</h4>
                    <p>22 April, 2025</p>
                  </div>
                
                  <div class="SettingsButtons"> 
                    <button id="aa-button" class="rating-button compact">
                      <span id="aa-label"><h4>Aa</h4></span>
                      <input type="range" min="0" max="30" value="10" step="10" class="rating-slider visible form-range" id="aa-slider">
                    </button>
                  </div>
                 </div>
            <br><hr />
            <div class="Main-Longread">
                <div class="Longread-Header"></div>
                <p id="article-text">Even ontnuchteren. Een zessterrenhotel? Dat bestaat niet. Er is geen enkele instantie die die kwalificatie verstrekt. Het CBS telt in Amsterdam 31 vijfsterrenhotels met een zeer compleet aanbod. Maar daaronder zijn een paar hotels die blijkbaar nÃ³g een stapje extra doen voor de gast. Zes sterren, dus hors catÃ©gorie.

                  <br><br>
                  Mogelijk kan het Amsterdamse Conservatorium Hotel, uit 2011, zich zo kwalificeren. Het Waldorf Astoria valt er zeker onder. Dat hotel opende in 2014 de deuren en is onderdeel van Hilton Worldwide.
                        Wat ze gemeen hebben met het nieuwe Rosewood Hotel, dat op 1 mei zijn deuren opent aan de Prinsengracht, is dat hun tweepersoonskamers beginnen bij â‚¬1000 per nacht.
                      </p>
                    
                 
                  <p id="article-text"> Maar het Rosewood heeft ook een suite van 141 vierkante meter, die vijftien keer zoveel kost. Die heeft een slaapkamer, een woonkamer en een eetkamer en uitzicht op de toren van de Westerkerk. </p>
                 
                  <br>
                    
                           <h4>Geen script</h4>
                        
                  <p id="article-text">
                    De Rosewood Hotel Group is een hotelketen met 55 hotels in 24 landen, eigendom van de steenrijke Hongkongse vastgoedfamilie Cheng. <br></p>
                  
                           <p id="article-text">
                            Sonia Cheng, kleindochter van de pater familias, Henry Cheng, leidt het bedrijf. In 2011 nam de familie de van oorsprong Amerikaanse Rosewood-keten over. <br><br>Sindsdien is Sonia Cheng bezig de hotels onder de Rosewood-vlag (de groep heeft ook nog andere merken) in een straf tempo uit te breiden. Op de site van het bedrijf wordt het merk omschreven als ultra-luxury.                   
                          
                          <div class="Scroll-HandImageA4 HandImage-LeftA4">
                          <img src="../Images/Peruse/Hand_Left.png" 
                          alt="Sonia Cheng or related visual">
                          </div>
                
                          <p id="article-text">
                    Wat betekent dat? Wat omvat die fameuze zessterrenservice? Dat probeert Thomas Harlander, directeur van het Amsterdamse Rosewood, die voorafgaand aan de opening al tweeÃ«nhalf jaar op zijn post zit, zo goed mogelijk uit te leggen. â€˜Elk luxehotel heeft zijn eigen credo en missieâ€™, zegt Harlander. â€˜In het Rosewood geven we iedere gast een tailormade behandeling. Waarom zou je iedereen hetzelfde behandelen? Er is geen script.â€™<br><br>
                    
                    Een voorbeeld van zoâ€™n persoonlijke benadering kan hij wel geven. â€˜De butler heeft ontdekt dat jouw favoriete parfum bijna op is. Kan gebeuren toch? Als je uitcheckt staat er een fris flesje, mooi verpakt. Dan hoef je niet zelf naar de winkel te gaan.â€™ <br><br>  
                  </p>            
              

                <h4>Niet in het reisprogramma</h4>
    
                  <p id="article-text">
                    Het is nog niet zo lang dat Amsterdam meedraait in de wereld van de exclusieve service voor een select gezelschap reizigers. Natuurlijk bezat de hoofdstad altijd al heel fraaie hotels waar de rich and famous neerstreken als ze hier waren uitgenodigd. Denk aan het Amstel Hotel. Maar voor een bepaalde groep welgestelde kosmopolieten zat Amsterdam tot voor kort eenvoudigweg niet in het reisprogramma. <br><br>

                    Harlander: â€˜Amsterdam is zeker niet Londen, niet Parijs, niet New York, wat luxury betreft. Het is er wel, maar niet in your face. Dit is een stad om te ontdekken. Elke hoek, elke wijk is anders. Naar mijn mening is het aanbod aan restaurants en bars dramatisch verbeterd de laatste jaren. Is het wereldklasse? Dat is niet aan mij om te beoordelen, maar ik zie veel veranderingen.â€™ <br><br>

                    Die ziet Roberto Payer ook, een zeer ervaren collega van Harlander, die inmiddels met pensioen is. â€˜Dat merk bestond helemaal niet, ook niet in Amerika. Het was vooral een legendeâ€™, zegt hij, doelend op het beroemde Waldorf Astoria-hotel in New York. Payer: â€˜Mijn baas dacht dat ik gek geworden was. Ze geloofden niet in luxury in Amsterdam. Amsterdam kende geen luxury. Wel een goed hotel, ja. Maar niet luxury.â€™  <br><br>
                  </p>

                  <h4>Twee Michelinsterren</h4>
    
                    <p id="article-text">Dat brengt ons bij een belangrijk onderdeel: food and beverage. Het nieuwe Rosewood krijgt een bar met de naam Advocatuur, waar je Indiase snacks kunt krijgen uit de tandoori-oven, voor bij een huisgemaakte gin/jenever met de naam Provo. De op maat gemaakte distilleerinstallatie staat in de bar en is een kunstwerk op zich. <br><br>
    
                      Het hotel herbergt ook een Indiase businessclub, een wens van de overleden burgemeester Eberhard van der Laan, waar het hotel zich aan moest houden. Daarnaast is er restaurant The Court, in de lobbylounge, een ruimte voor evenementen Ã©n een hoofdrestaurant, Eeuwen geheten. Als je inhouse dining meetelt (de suites hebben een eetkamer) zijn er vijf plekken in het hotel waar je iets kunt eten of drinken.</p>

                      <div class="Scroll-HandImageA4 HandImage-RightA4">
                        <img src="../Images/Peruse/Hand_Right.png" 
                        alt="Sonia Cheng or related visual">
                        </div>

                        <p id="article-text">
                       â€˜Vijf eetgelegenheden? Dan wens ik ze veel sterkteâ€™, reageert Krooswijk, die nog wel een tip heeft voor het Rosewood. â€˜Toen we bij hotel De lâ€™Europe na een ingrijpende verbouwing opengingen, hebben we ervoor gezorgd dat het restaurant binnen een jaar weer twee Michelin-sterren kreeg. Dat is heel belangrijk voor de Amerikaanse markt.â€™ <br><br></p>

                       <div class="Longform-Image-Container"> 
                        <picture>
                            <source srcset="../Images/Peruse/GrafiekMichelin_Phone.png" media="(max-width: 768px)"> 
                            
                            <img src="../Images/Peruse/GrafiekMichelin.png" alt="Descriptive Alt Text for Image 2">
                        </picture>
                    </div>
                        

                    <p id="article-text">
                      Hoe denkt Thomas Harlander van het Rosewood daarover? â€˜Er zijn hotels die hun pink afhakken voor een ster, maar als mijn gasten een Michelin-sterrenervaring willen, stuur ik ze wel door naar mijn vrienden in De lâ€™Europe en het Waldorfâ€™, zegt hij. â€˜Het is heel moeilijk met een Michelin-sterrenrestaurant geld te verdienen. In AziÃ«, vooral in Japan, zie je dat chefs geen ster meer willen. Ze hebben ze niet nodig. We zeggen er geen nee tegen, maar een Michelin-ster is niet hetzelfde als succes. Wij gaan onze restaurants vanaf dag Ã©Ã©n zo opzetten dat ze financieel succesvol zijn.â€™<br><br>
                                          
                       
                          Het Rosewood is superhigh-end, maar dat is niet hetzelfde als overdreven luxe, vindt ontwerper Piet Boon. â€˜Het Rosewood wil ook een hotel zijn voor de buurt. Dat je er, als je daar om de hoek woont, lekker in de tuin gaat zitten en een kop koffie gaat drinken.â€™
                        </p>
            
            </div>

            

            <br><br><br><br><br><br><br><br>

     

        </div>
        </div>
        
      </main>

      <div class="Rating"> 
        <h3>Beoordeling van geloofwaardigheid</h3>
        <p id="article-text">
          De mate waarin je dit artikel als geloofwaardig hebt ervaren, op een schaal van 1 tot 100.
        </p><br>
        <div class="schaalinfo">
          <p id="info-links">helemaal niet geloofwaardig</p>
          <p id="info-rechts">zeer geloofwaardig</p>
        </div>
        <br>
        <div class="Range_container">
          <div class="range-slider">
            <div id="slider_thumb" class="range-slider_thumb"></div>
            <div class="range-slider_line">
              <div id="slider_line" class="range-slider_line-fill"></div>
            </div>
            <input id="slider_input" class="range-slider_input" type="range" value="50" min="0" max="100">
          </div>
        </div>
        <div class="container">
          <button id="submitBtn" class="btn inactive">Verstuur</button>
        </div>
      </div>


   

        <footer class="footer">
            <div id="back-to-top" class="footerdiv">
                <div class="scrollwatcher"></div>
                <br>
            </div>
        </footer>
    

        <script type="module">

import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm";

// Initialize Supabase client
const supabaseUrl = 'https://rgoydwojepkjbqzdldft.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJnb3lkd29qZXBramJxemRsZGZ0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzk3MTMyMTYsImV4cCI6MjA1NTI4OTIxNn0.gjk1wM4DUaxAQV9H3zK3hzktav-Pjo40fEIDHR7DTWQ';
const supabaseClient = createClient(supabaseUrl, supabaseKey);

// User ID management functions
function getUserIdFromLocalStorage() {
  return localStorage.getItem("userId");
}
function isUserIdInLocalStorage() {
  return !!getUserIdFromLocalStorage();
}
function generateUUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    const r = (Math.random() * 16) | 0,
          v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}
function setUserIdInLocalStorage() {
  const newId = generateUUID();
  console.log("Generated UserID:", newId);
  localStorage.setItem("userId", newId);
}
if (!isUserIdInLocalStorage()) {
  setUserIdInLocalStorage();
}

async function insertScriptieVertrouwen(sliderValue, timeSpent) {
  const submitDate = new Date().toISOString();
  
  const { data, error } = await supabaseClient
    .from("scriptie_vertrouwen")
    .insert([{
      slider_values: sliderValue,
      article_number: "A4",  // Force article number to always be "B"
      user_id: getUserIdFromLocalStorage(),
      time_spent: timeSpent,
      submit_date: submitDate
    }]);
    
  if (error) {
    console.error("Error inserting into scriptie_vertrouwen:", error);
  } else {
    console.log("Successfully inserted into scriptie_vertrouwen:", data);
  }
}

// Wait for the DOM to fully load
document.addEventListener("DOMContentLoaded", function () {
  // Record page load time (in milliseconds)
  const pageLoadTime = Date.now();

  // === New Slider Functionality ===
  const slider_input = document.getElementById("slider_input");
  const slider_thumb = document.getElementById("slider_thumb");
  const slider_line = document.getElementById("slider_line");
  const submitBtn = document.getElementById("submitBtn");
  let sliderChanged = false; // Initially, the slider has not been changed

  function showSliderValue() {
    slider_thumb.innerHTML = slider_input.value;
    const bulletPosition = slider_input.value / slider_input.max;
    const space = slider_input.offsetWidth - slider_thumb.offsetWidth;
    slider_thumb.style.left = (bulletPosition * space) + 'px';
    slider_line.style.width = slider_input.value + '%';
  }
  // Call once to set up initial position (without marking as changed)
  showSliderValue();
  window.addEventListener("resize", showSliderValue);
  slider_input.addEventListener('input', () => {
    showSliderValue();
    if (!sliderChanged) {
      sliderChanged = true;
      submitBtn.classList.remove("inactive");
      submitBtn.classList.add("active");
    }
  }, false);

  // === Submit Button, Confirmation, Animation & Redirect ===
  submitBtn.addEventListener("click", async () => {
    // Keep the check if the slider value was changed
    if (!sliderChanged) {
      const proceed = confirm("You have not changed the slider value from its default. Do you want to submit this number?");
      if (!proceed) {
        return; // Stop if the user cancels
      }
    }

    // Get the final slider value and time spent
    const sliderValue = Number(slider_input.value);
    const timeSpent = Math.floor((Date.now() - pageLoadTime) / 1000); // Time in seconds

    console.log("Submit clicked. Slider value:", sliderValue, "Time spent (s):", timeSpent);

    // ----- NEW SIMPLIFIED LOGIC -----
    // Use generic keys for ALL A-type articles
    const genericArticleAReadKey = "article_A_read";
    const genericArticleAScoreKey = "article_A_score";

    // Store the read status and score using the generic keys
    // Reading any A article will now overwrite these keys
    localStorage.setItem(genericArticleAReadKey, "true");
    localStorage.setItem(genericArticleAScoreKey, sliderValue);
    // ----- END NEW SIMPLIFIED LOGIC -----

    // --- Supabase Data ---
    // IMPORTANT: Even though localStorage is generic, your database likely
    // still needs the SPECIFIC article ID (A1, A2, etc.).
    // Your 'insertScriptieVertrouwen' function *might* already handle this
    // if it's defined differently in each file (e.g., hardcoding "A1" inside
    // the function in a1.html). Double-check how that function gets the article_number.
    // Assuming it handles the specific ID correctly internally:
    await insertScriptieVertrouwen(sliderValue, timeSpent);


    // Disable the button, trigger animation, and redirect (keep this logic)
    submitBtn.disabled = true;
    $(submitBtn).addClass('btn-progress'); // Assuming jQuery animation class

    setTimeout(() => {
      $(submitBtn).addClass('btn-fill');
    }, 500); // Animation timing

    setTimeout(() => {
      $(submitBtn).removeClass('btn-fill').addClass('btn-complete');
    }, 4100); // Animation timing

    // Redirect back to the main page after the animation completes
    setTimeout(() => {
      window.location.href = "../html/peruse.html"; // Adjust path if needed
    }, 4100); // Should match the end of the animation
});

  // === Article Visibility & Toggle ===
  const options = ["A1", "A2", "A3", "A4", "B1", "B2"];
  const storageKey = "selectedAOption";
  let selectedOptionIndex = localStorage.getItem(storageKey);

  if (selectedOptionIndex === null) {
    selectedOptionIndex = Math.floor(Math.random() * options.length);
    localStorage.setItem(storageKey, selectedOptionIndex);
  } else {
    selectedOptionIndex = Number(selectedOptionIndex);
  }

  const selectedOption = options[selectedOptionIndex];
  const selectedElement = document.getElementById(selectedOption);
  if (selectedElement) {
    selectedElement.classList.remove("hidden");
    selectedElement.classList.add("visible");
  } else {
    console.error(`Element with id "${selectedOption}" not found.`);
  }

  const article = document.querySelector(".Longread-ArticleA");
if (article) {
  window.addEventListener("scroll", function () {
    const scrollY = window.scrollY;
    const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
    const fadeStart = maxScroll * 0.3;
    const fadeEnd = maxScroll * 0.5;

    if (scrollY >= fadeStart && scrollY <= fadeEnd) {
      let progress = (scrollY - fadeStart) / (fadeEnd - fadeStart);
      let r = Math.round(69 * (1 - progress));
      let g = Math.round(18 * (1 - progress));
      let b = Math.round(18 * (1 - progress));
      article.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
    } else if (scrollY > fadeEnd) {
      article.style.backgroundColor = "#000000";
    } else {
      article.style.backgroundColor = "#451212";
    }
  });
} else {
  console.error("Element with class 'Longread-ArticleA' not found.");
}
          
              // === Scroll Watcher Progress Bar ===
              const toggleVisibilityClass = (element, visibleClass) => {
  const isScrollable = document.body.scrollHeight > window.innerHeight;
  const isScrolled = window.scrollY > 0;
  if (isScrollable && isScrolled) {
    element.classList.add(visibleClass);
  } else {
    element.classList.remove(visibleClass);
  }
};

// === Scroll Progress Bar ===
const scrollWatcher = document.querySelector('.scrollwatcher');
if (scrollWatcher) {
  window.addEventListener('scroll', () => {
    const scrollTop = window.scrollY;
    const docHeight = document.documentElement.scrollHeight - window.innerHeight;
    const progress = Math.min(scrollTop / docHeight, 1);
    scrollWatcher.style.transform = `scaleX(${progress})`;
  });
} else {
  console.error("Element with class 'scrollwatcher' not found.");
}

// === Back-to-Top Button ===
const backToTopButton = document.getElementById("back-to-top");
if (backToTopButton) {
  const updateBackToTopVisibility = () => {
    toggleVisibilityClass(backToTopButton, "visible");
  };

  backToTopButton.addEventListener("click", () => {
    window.scrollTo({ top: 0, behavior: "smooth" });
  });

  window.addEventListener("scroll", updateBackToTopVisibility);
  window.addEventListener("resize", updateBackToTopVisibility);
  updateBackToTopVisibility();
} else {
  console.error("Back-to-top element not found.");
}

// === Footer bar or scroll element ===
const footerBar = document.getElementById("footer-bar"); // or .querySelector('.your-class')
if (footerBar) {
  const updateFooterVisibility = () => {
    toggleVisibilityClass(footerBar, "visiblefooter");
  };

  window.addEventListener("scroll", updateFooterVisibility);
  window.addEventListener("resize", updateFooterVisibility);
  updateFooterVisibility();
}
          
              // === Mobile Menu Toggle ===
              const menuToggle = document.getElementById("menu-toggle");
              if (menuToggle) {
                menuToggle.addEventListener("click", function(){
                  const links = document.getElementById("myLinks");
                  if (links) {
                    links.style.display = links.style.display === "block" ? "none" : "block";
                  } else {
                    console.error("Element with id 'myLinks' not found.");
                  }
                });
              }
          
              // === Adjust Widths for .scroll divs ===
              document.querySelectorAll('.scroll div').forEach(div => {
                const contentWidth = Array.from(div.children).reduce((total, child) => total + child.offsetWidth + 20, 0);
                div.style.width = `${contentWidth}px`;
              });
            });

            const slider_input = document.getElementById('slider_input'),
      slider_thumb = document.getElementById('slider_thumb'),
      slider_line = document.getElementById('slider_line');

function showSliderValue() {
  slider_thumb.innerHTML = slider_input.value;
  const bulletPosition = (slider_input.value /slider_input.max),
        space = slider_input.offsetWidth - slider_thumb.offsetWidth;

  slider_thumb.style.left = (bulletPosition * space) + 'px';
  slider_line.style.width = slider_input.value + '%';
}

showSliderValue();
window.addEventListener("resize",showSliderValue);
slider_input.addEventListener('input', showSliderValue, false);

document.addEventListener('DOMContentLoaded', function () {

const button = document.getElementById('aa-button');
const label = document.getElementById('aa-label'); // Although not used in logic, keep if needed elsewhere
const slider = document.getElementById('aa-slider');

// Key for storing the slider value in localStorage
const storageKey = 'userFontSizeSliderValue';

// Font size values corresponding to the slider steps
const fontSizes = [14, 18, 22, 28]; // 4 sizes for the 4 steps (0, 10, 20, 30)

// To store whether the button is expanded or not
let expanded = false;

// --- Helper Functions ---

// Function to apply the font size based on the slider value
function applyFontSize(sliderValue) {
    // Ensure sliderValue is treated as a number
    const value = parseInt(sliderValue, 10);
    // Calculate index, ensuring it's within bounds
    const index = Math.min(Math.max(value / 10, 0), fontSizes.length - 1);
    const fontSize = fontSizes[index];

    // Apply this font size to all relevant <p> elements
    // Note: IDs should be unique. If you have multiple paragraphs, consider using a class instead, e.g., '.article-text'
    const articleTextElements = document.querySelectorAll('#article-text');
    articleTextElements.forEach(p => {
        p.style.fontSize = `${fontSize}px`;
    });

    // Ensure the slider visually matches the applied value
    slider.value = value;
}

// Function to save the current slider value to localStorage
function saveSetting() {
    localStorage.setItem(storageKey, slider.value);
}

// Function to load the setting from localStorage and apply it
function loadAndApplySetting() {
    const savedValue = localStorage.getItem(storageKey);
    let initialSliderValue;

    // Check if a value was found in localStorage
    if (savedValue !== null) {
        initialSliderValue = parseInt(savedValue, 10);
        // Basic validation: ensure it's a number within the slider's range and steps
        if (isNaN(initialSliderValue) || initialSliderValue < slider.min || initialSliderValue > slider.max || initialSliderValue % slider.step !== 0) {
            console.warn('Invalid font size value found in localStorage. Using default.');
            initialSliderValue = 10; // Use default (matches HTML value="10")
            localStorage.removeItem(storageKey); // Optional: Remove the invalid value
        }
    } else {
        // No saved value, use the default from the HTML slider element
        initialSliderValue = parseInt(slider.value, 10); // Default is 10 based on your HTML
    }

    // Apply the loaded or default font size
    applyFontSize(initialSliderValue);
}

// --- Event Listeners ---

button.addEventListener('click', function () {
    // Toggle visibility of the slider
    if (!expanded) {
        slider.classList.remove('hidden'); // Assuming you have CSS rules for .hidden
        button.classList.remove('compact'); // Assuming you have CSS rules for .compact
        expanded = true;
    } else {
        slider.classList.add('hidden');
        button.classList.add('compact');
        expanded = false;
    }
    // Ensure initial state of slider visibility matches 'expanded' status if needed
    // e.g., if slider starts hidden:
    // if (!expanded) slider.classList.add('hidden');
});

slider.addEventListener('input', function () {
    // Apply the font size based on the current slider value
    applyFontSize(this.value);
    // Save the new setting to localStorage immediately
    saveSetting();
});

// --- Initialization ---

// Load the saved setting (or default) when the page loads
loadAndApplySetting();

// Initial setup for button/slider visibility (assuming it starts compact and hidden)
if (!expanded) {
    slider.classList.add('hidden');
    button.classList.add('compact');
}

});

document.addEventListener('DOMContentLoaded', () => {
    // --- Element Selection ---
    const numberElement = document.getElementById('countup-number');
    const orderButton = document.getElementById('order-button');

    // Check if elements exist
    if (!numberElement) {
        console.error('Element with ID "countup-number" not found.');
        return;
    }
    if (!orderButton) {
        console.error('Element with ID "order-button" not found.');
        // return; // Or allow script to continue without button features
    }

    // --- Animation State ---
    let currentAnimationFrameId = null;

    // --- Reusable Animation Function (Keep as is) ---
    function animateCounter(element, targetValue, duration) {
        if (currentAnimationFrameId) {
            cancelAnimationFrame(currentAnimationFrameId);
        }
        let startValue = 0;
        let startTime = null;
        const currentText = element.textContent || '';
        const cleanedText = currentText.replace(/â‚¬|\s/g, '').replace(/\./g, '').replace(',', '.');
        const parsedValue = parseFloat(cleanedText);
        if (!isNaN(parsedValue)) {
            startValue = parsedValue;
        } else {
            console.warn(`Could not parse number from "${currentText}", starting from 0.`);
        }

        function easeInCubic(t) { return t * t * t; }

        const step = (timestamp) => {
            if (!startTime) startTime = timestamp;
            const elapsedTime = timestamp - startTime;
            let progress = Math.min(elapsedTime / duration, 1);
            const easedProgress = easeInCubic(progress);
            const currentValue = startValue + (targetValue - startValue) * easedProgress;
            element.textContent = `â‚¬${Math.ceil(currentValue).toLocaleString('nl-NL', { maximumFractionDigits: 0 })}`;
            if (progress < 1) {
                currentAnimationFrameId = requestAnimationFrame(step);
            } else {
                element.textContent = `â‚¬${targetValue.toLocaleString('nl-NL', { maximumFractionDigits: 0 })}`;
                currentAnimationFrameId = null;
                startTime = null;
            }
        };
        currentAnimationFrameId = requestAnimationFrame(step);
    }

    // --- Intersection Observer for Initial Animation (Keep as is) ---
    const observerOptions = {
        root: null,
        rootMargin: "-40% 0px -40% 0px",
        threshold: 0
    };
    const startAnimationCallback = (entries, observer) => {
        entries.forEach(entry => {
             // Using currentAnimationFrameId === null as a simple flag to run once
            if (entry.isIntersecting && currentAnimationFrameId === null && !numberElement.dataset.initialAnimationDone) {
                 const initialTarget = parseInt(numberElement.getAttribute('data-target'), 10) || 1000;
                 const initialDuration = 2000;
                 animateCounter(numberElement, initialTarget, initialDuration);
                 numberElement.dataset.initialAnimationDone = 'true'; // Set flag on number element
                 observer.unobserve(entry.target);
            }
        });
    };
    const observer = new IntersectionObserver(startAnimationCallback, observerOptions);
    if(numberElement){ // Observe only if element exists
        observer.observe(numberElement);
    }


    // --- Button Click Listener (MODIFIED) ---
    if(orderButton) { // Add listener only if button exists
        orderButton.addEventListener('click', () => {
            // Existing values (Note: Target changed in your provided code)
            const newTarget = 15605; // Using the value from your latest code snippet
            const clickDuration = 2500;

            console.log("Order button clicked, scrolling, animating and updating style."); // Updated log

            // ***** ADD THIS SECTION *****
            // --- Scroll to Teleport Target ---
            const teleportTarget = document.getElementById('teleport');
            if (teleportTarget) {
                teleportTarget.scrollIntoView({
                    behavior: 'smooth', // Smooth scroll
                    block: 'start'      // Align target's top with viewport's top
                });
            } else {
                console.warn('Element with id="teleport" not found for scrolling.');
            }
            // --- End Scroll ---
            // ***** END OF ADDED SECTION *****


            // 1. Trigger the number animation (Existing)
            animateCounter(numberElement, newTarget, clickDuration);

            // --- Style and State Updates for Button (Existing) ---
            // 2. Change button color class
            orderButton.classList.remove('btn-primary'); // Remove blue
            orderButton.classList.add('btn-success');   // Add green

            // 3. Change button text
            orderButton.textContent = 'Gereserveerd';

            // 4. Disable the button
            orderButton.disabled = true;
            // --- End Style Updates ---
        });
    }

}); 

document.addEventListener('DOMContentLoaded', function() {
    const mapElement = document.getElementById('map');
    if (mapElement) {
        const amsterdamCoords = [52.372, 4.894];
        const initialZoom = 13;
        const map = L.map('map').setView(amsterdamCoords, initialZoom);

        // --- MODIFIED: Use CartoDB Dark Matter Tile Layer (Free) ---
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            // Update attribution for CartoDB and OpenStreetMap
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd', // Standard for CartoDB tiles
            maxZoom: 19 // CartoDB's typical max zoom level
        }).addTo(map);
        // --- END MODIFIED ---


        // --- Hotel Data (Keep as before) ---
        const hotelData = [ /* ... Your hotel data array ... */
            { name: "Amstel Hotel", lat: 52.359984, lng: 4.905243, category: "Voor 1980" },
            { name: "Hotel De L'Europe", lat: 52.367644, lng: 4.894466, category: "Voor 1980" },
            { name: "Doelen Hotel", lat: 52.36825, lng: 4.895859, category: "Voor 1980" },
            { name: "Grand Hotel Krasnapolsky", lat: 52.372729, lng: 4.894385, category: "Voor 1980" },
            { name: "Hilton Hotel", lat: 52.35143, lng: 4.872012, category: "Voor 1980" },
            { name: "Pulitzer Amsterdam", lat: 52.372823, lng: 4.883399, category: "Voor 1980" },
            { name: "Hotel Okura Amsterdam", lat: 52.348585, lng: 4.893625, category: "Voor 1980" },
            { name: "Marriott Hotel", lat: 52.362549, lng: 4.880125, category: "Voor 1980" },
            { name: "Renaissance Hotel", lat: 52.378156, lng: 4.894397, category: "Voor 1980" },
            { name: "Garden Hotel", lat: 52.35118, lng: 4.874002, category: "1980-2010" },
            { name: "Barbizon Palace", lat: 52.376486, lng: 4.900472, category: "1980-2010" },
            { name: "The Grand", lat: 52.370945, lng: 4.895604, category: "1980-2010" },
            { name: "Hotel 717", lat: 52.364791, lng: 4.885341, category: "1980-2010" },
            { name: "The Dylan Amsterdam", lat: 52.369279, lng: 4.883983, category: "1980-2010" },
            { name: "The College Hotel", lat: 52.352776, lng: 4.883686, category: "1980-2010" },
            { name: "Grand Hotel AmrÃ¢th Amsterdam", lat: 52.374647, lng: 4.903879, category: "1980-2010" },
            { name: "Conservatorium Hotel", lat: 52.358605, lng: 4.878526, category: "Vanaf 2010" },
            { name: "Andaz Amsterdam Prinsengracht", lat: 52.367908, lng: 4.882883, category: "Vanaf 2010" },
            { name: "Waldorf Astoria", lat: 52.364671, lng: 4.89694, category: "Vanaf 2010" },
            { name: "W Amsterdam", lat: 52.3728, lng: 4.889758, category: "Vanaf 2010" },
            { name: "Hotel TwentySeven", lat: 52.37251, lng: 4.893336, category: "Vanaf 2010" },
            { name: "Kimpton De Witt Hotel", lat: 52.377234, lng: 4.895533, category: "Vanaf 2010" },
            { name: "Hyatt Regency Amsterdam Hotel", lat: 52.361778, lng: 4.911721, category: "Vanaf 2010" },
            { name: "Amsterdam Riverside Hotel", lat: 52.353377, lng: 4.907169, category: "Vanaf 2010" },
            { name: "Grand Boutique Hotel Maurits at the Park", lat: 52.362199, lng: 4.91965, category: "Vanaf 2010" },
            { name: "The Diamond Amsterdam", lat: 52.363776, lng: 4.883282, category: "Vanaf 2010" },
            { name: "Rosewood Amsterdam", lat: 52.365751, lng: 4.882848, category: "Vanaf 2010" }
        ];

        // --- Define Colors for Categories (Keep as before) ---
        const categoryColors = { /* ... Your category colors ... */
             "Voor 1980": "#ffbeaa", "1980-2010": "#f05031", "Vanaf 2010": "#dc3545", "default": "#6c757d"
        };
        function getColor(category) { /* ... Your getColor function ... */
             return categoryColors[category] || categoryColors.default;
         }

        // --- Add Markers (Keep lighter border color) ---
        console.log(`Adding ${hotelData.length} hotel markers...`);
        hotelData.forEach(hotel => {
            const lat = parseFloat(hotel.lat);
            const lng = parseFloat(hotel.lng);
            const category = hotel.category;
            // Slightly improved check for valid coordinates and name
            if (hotel.name && typeof lat === 'number' && !isNaN(lat) && typeof lng === 'number' && !isNaN(lng)) {
                const markerOptions = {
                    radius: 7,
                    fillColor: getColor(category),
                    color: "#CCCCCC", // Lighter border color good for dark maps
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.85
                };
                const marker = L.circleMarker([lat, lng], markerOptions).addTo(map);
                marker.bindPopup(`<b>${hotel.name}</b><br><i>${category}</i>`);
            } else {
                 // More specific warning for debugging
                 console.warn(`Skipping hotel due to invalid data: Name=${hotel.name}, Lat=${hotel.lat}, Lng=${hotel.lng}`);
            }
        });

        console.log("Leaflet map initialized with CartoDB dark theme and markers."); // Update log message

    } else {
         // More specific error message
         console.error("Map container element with ID 'map' not found in the DOM.");
    }
});

document.addEventListener('DOMContentLoaded', () => {
    // --- Reveal/Collapse Logic ---
    const trigger = document.getElementById('cdb-trigger'); 
    const content = document.getElementById('cdb-audiovisual');

    if (trigger && content) {
        const toggleContent = () => {
            const isVisible = content.classList.contains('visible');
            if (isVisible) {
                content.classList.remove('visible');
                trigger.classList.remove('active');
                trigger.setAttribute('aria-expanded', 'false');
            } else {
                content.classList.add('visible');
                trigger.classList.add('active');
                trigger.setAttribute('aria-expanded', 'true');
                // Optional: Scroll the content into view slightly after opening
                // setTimeout(() => {
                //    content.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                // }, 700); // Delay matches transition time
            }
        };

        // Click event
        trigger.addEventListener('click', toggleContent);

        // Keyboard event (Enter/Space) for accessibility
        trigger.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault(); // Prevent page scroll on Space
                toggleContent();
            }
        });

    } else {
        console.error("Inline trigger or collapsible content element not found. Check IDs: #cdb-trigger, #cdb-audiovisual");
    }

    // --- Parallax Scroll Logic (Keep from previous step) ---
    const wrapper = content; // Use the 'content' variable which refers to the wrapper
    const parallaxText = wrapper ? wrapper.querySelector('.Parallax_Text') : null;

    if (wrapper && parallaxText) {
        const speedFactor = 1.2; 
        let isTicking = false;

        function updateParallax() {
            // Only run if wrapper is visible
            if (!wrapper.classList.contains('visible')) {
                isTicking = false;
                return; 
            }

            const rect = wrapper.getBoundingClientRect();
             // Avoid calculations if not in viewport
            if (rect.bottom < 0 || rect.top > window.innerHeight) {
                 isTicking = false;
                 return;
            }

            const wrapperHeight = wrapper.offsetHeight;
            const viewportHeight = window.innerHeight;
            const wrapperCenterY = rect.top + wrapperHeight / 2;
            const screenCenterY = viewportHeight / 2;
            const diff = screenCenterY - wrapperCenterY; 
            const translateY = -diff * speedFactor; 

            parallaxText.style.transform = `translateX(-50%) translateY(${translateY}px)`;
            isTicking = false;
        }

        function onScroll() {
            if (!isTicking) {
                window.requestAnimationFrame(updateParallax);
                isTicking = true;
            }
        }

        window.addEventListener('scroll', onScroll);
        window.addEventListener('resize', () => {
           if (!isTicking) {
               window.requestAnimationFrame(updateParallax);
               isTicking = true;
           }
        });
    } else {
         console.error("Parallax elements not found within #cdb-audiovisual.");
    }
});

document.addEventListener('DOMContentLoaded', () => {

const animatedImages = document.querySelectorAll('.HandImage-Left img, .HandImage-Right img');

if (animatedImages.length === 0) {
    console.warn("No elements found for scroll animation with selectors '.HandImage-Left img, .HandImage-Right img'");
    return;
}

let isTicking = false;

function handleScrollAnimations() {
    if (!isTicking) {
        window.requestAnimationFrame(() => {
            const vh = window.innerHeight;

            animatedImages.forEach(image => {
                const rect = image.getBoundingClientRect();
                const elementTop = rect.top;

                // --- Define the Scroll Zone for Animation ---

                // *** MODIFIED START POINT ***
                // Start when the top edge is 90% from the top of the viewport (10% in view)
                const animationStartPoint = vh * 0.9; 
                // *** END MODIFICATION ***

                // End when the top edge reaches the middle of the viewport (remains same)
                const animationEndPoint = vh * 0.5; 
                // Calculate the total distance over which the animation occurs
                const animationDistance = animationStartPoint - animationEndPoint;

                // Calculate progress (0 at start point, 1 at end point)
                let progress = 0;
                 // Prevent division by zero if start/end points overlap or distance is negative
                if (animationDistance > 0) { 
                    const distanceScrolledInZone = animationStartPoint - elementTop;
                    progress = distanceScrolledInZone / animationDistance;
                } else if (elementTop < animationEndPoint) { 
                     // If past the end point, progress is 1
                     progress = 1;
                }

                // Clamp progress between 0 and 1
                progress = Math.max(0, Math.min(1, progress));

                // Calculate Styles based on Progress
                const currentOpacity = progress;
                let startTranslateX = -80; // Default left
                const parentWrapper = image.closest('.Scroll-HandImage');
                if (parentWrapper && parentWrapper.classList.contains('HandImage-Right')) {
                    startTranslateX = 80; // Set positive for right
                }
                const currentTranslateX = startTranslateX * (1 - progress);

                // Apply Styles
                image.style.opacity = currentOpacity;
                image.style.transform = `translateX(${currentTranslateX}%)`;

            }); // End forEach

            isTicking = false;
        }); // End requestAnimationFrame
        isTicking = true;
    }
} // End handleScrollAnimations

// Initial call & Listeners (Keep as before)
handleScrollAnimations();
window.addEventListener('scroll', handleScrollAnimations, { passive: true });
window.addEventListener('resize', handleScrollAnimations, { passive: true });

console.log(`Scroll animations initialized for ${animatedImages.length} elements.`);

// --- Include the rest of your page's JavaScript below ---
// (e.g., number animation, map init, button clicks, font slider etc.)
// Ensure they are correctly placed, likely after the element selections

});

document.addEventListener('DOMContentLoaded', function() {
    // --- Sterren Selector Setup ---
    const ratingContainer = document.getElementById('michelin-rating');
    const stars = ratingContainer.querySelectorAll('.michelin-star');
    const ratingDisplay = document.getElementById('current-rating-display');
    const emptyStarSrc = '../Images/Peruse/Michelin_Empty.png'; // Jouw pad
    const fullStarSrc = '../Images/Peruse/MichelinStar_Full.png'; // Jouw pad
    let currentRating = 1;

    // *** NEW: Flag to track if initial blinking is active ***
    let initialBlinkActive = true;

    // *** NEW: Add blinking class on page load ***
    stars.forEach(star => {
        star.classList.add('blinking-stars');
    });

    function updateStarsVisual(rating) {
        stars.forEach((star, index) => {
            const starValue = index + 1;
            if (starValue <= rating) {
                star.src = fullStarSrc;
                star.alt = `Rating: ${starValue} ster(ren)`;
            } else {
                star.src = emptyStarSrc;
                star.alt = `Rate ${starValue} ster(ren)`;
            }
        });
        if (ratingDisplay) {
            ratingDisplay.textContent = `Aantal Michelin ${rating}-ster restaurants`;
            if (rating === 0) {
                 ratingDisplay.textContent = `Selecteer een sterren-niveau`;
            }
        }
    }

    // --- Chart.js Setup ---
    const ctx = document.getElementById('michelinBarChart').getContext('2d');
    let barChart = null;

    // Note: Updated Dutch labels are used here
    const chartRawData = {
        labels: ['Nederland', 'BelgiÃ«', 'Frankrijk', 'Duitsland', 'Verenigd Koninkrijk', 'Zwitserland'],
        datasets: {
            '1': [102, 128, 534, 280, 170, 108],
            '2': [19, 23, 75, 50, 27, 26],
            '3': [1, 2, 30, 10, 9, 4]
        },
        titles: { '1': '', '2': '', '3': '' },
        colors: {
            '1': 'rgba(173, 221, 142, 0.6)', '2': 'rgba(254, 217, 118, 0.6)', '3': 'rgba(228, 26, 28, 0.6)'
        },
        borderColors: {
           '1': 'rgba(173, 221, 142, 1)', '2': 'rgba(254, 217, 118, 1)', '3': 'rgba(228, 26, 28, 1)'
        }
    };

    // Note: flagMap keys need to match chartRawData.labels for flags to show
    // Using English keys here based on previous code. Adjust if needed.
    const flagMap = {
        'Nederland': 'ðŸ‡³ðŸ‡±',           // Key matches label
        'BelgiÃ«': 'ðŸ‡§ðŸ‡ª',              // Key matches label
        'Frankrijk': 'ðŸ‡«ðŸ‡·',           // Key matches label
        'Duitsland': 'ðŸ‡©ðŸ‡ª',           // Key matches label
        'Verenigd Koninkrijk': 'ðŸ‡¬ðŸ‡§', // Key matches label
        'Zwitserland': 'ðŸ‡¨ðŸ‡­'          // Key matches label
    };
    // If you used English labels before:
    // const flagMap = {
    //     'Netherlands': 'ðŸ‡³ðŸ‡±', 'Belgium': 'ðŸ‡§ðŸ‡ª', 'France': 'ðŸ‡«ðŸ‡·',
    //     'Germany': 'ðŸ‡©ðŸ‡ª', 'UK': 'ðŸ‡¬ðŸ‡§', 'Switzerland': 'ðŸ‡¨ðŸ‡­'
    // };


    function renderOrUpdateChart(rating) {
        if (rating < 1 || rating > 3) {
             if (barChart) { barChart.destroy(); barChart = null; }
            return;
        }
        const ratingStr = rating.toString();
        const dataToShow = chartRawData.datasets[ratingStr];
        const titleToShow = chartRawData.titles[ratingStr];
        const colorToShow = chartRawData.colors[ratingStr];
        const borderColorToShow = chartRawData.borderColors[ratingStr];

        const chartOptions = {
            responsive: true, maintainAspectRatio: false,
            plugins: {
                title: { display: true, text: titleToShow, font: { size: 16 } },
                legend: { display: false },
            },
            scales: {
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Aantal Restaurants' }
                },
                x: {
                    // Updated title to use Dutch source text
                    title: { display: true, text: 'bron: Michelin, 2024' },
                    grid: {
                        display: false
                    },
                    ticks: {
                         display: true,
                         color: '#a1a1a1',
                         font: {
                             size: 12,
                             family: "'Noto Color Emoji', 'Segoe UI Emoji', 'Apple Color Emoji', sans-serif"
                         },
                         callback: function(value, index, ticks) {
                            const label = this.getLabelForValue(value); // Gets the label from chartRawData.labels
                            const flag = flagMap[label] || '?'; // Looks up based on that label
                            // console.log(`Tick Callback - Index: ${index}, Label: "${label}", Flag: ${flag}`);
                            return [flag, label];
                        }
                    },
                    afterFit: function(scaleInstance) {
                        scaleInstance.height = scaleInstance.height + 20;
                    }
                }
            }
        };

        if (barChart) {
            barChart.data.datasets[0].data = dataToShow;
            barChart.data.datasets[0].backgroundColor = colorToShow;
            barChart.data.datasets[0].borderColor = borderColorToShow;
            barChart.options.plugins.title.text = titleToShow;
            // Ensure options using the new font are applied on update
            barChart.options.scales.x.ticks.font.family = chartOptions.scales.x.ticks.font.family;
            barChart.options.scales.x.afterFit = chartOptions.scales.x.afterFit; // Re-apply afterFit too
            barChart.options.scales.x.ticks.callback = chartOptions.scales.x.ticks.callback; // Re-apply callback
            barChart.update();
        } else {
            barChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: chartRawData.labels, // Use the Dutch labels here
                    datasets: [{
                        label: 'Aantal Restaurants', data: dataToShow,
                        backgroundColor: colorToShow, borderColor: borderColorToShow, borderWidth: 1
                    }]
                },
                options: chartOptions
            });
        }
    }

    // --- Event Listeners Sterren ---
    stars.forEach(star => {
        star.addEventListener('click', function() {
            // *** NEW: Stop blinking on first click ***
            if (initialBlinkActive) {
                stars.forEach(s => s.classList.remove('blinking-stars')); // Remove from all stars
                initialBlinkActive = false; // Stop blinking permanently
            }

            // --- Original click logic ---
            const clickedValue = parseInt(this.getAttribute('data-value'));
            if (currentRating !== clickedValue) {
                currentRating = clickedValue;
                updateStarsVisual(currentRating);
                renderOrUpdateChart(currentRating);
            }
             // No console log here in original code, removed
        });

        star.addEventListener('mouseover', function() {
             // Original hover logic: Preview rating
             const hoverValue = parseInt(this.getAttribute('data-value'));
             // Temporarily show fill state up to the hovered star (Different from updateStarsVisual)
             stars.forEach((s, index) => {
                 s.src = (index < hoverValue) ? fullStarSrc : emptyStarSrc;
             });
        });

        star.addEventListener('mouseout', function() {
            // Original mouseout logic: Restore visual based on currentRating
            updateStarsVisual(currentRating);
        });
    });

     // --- Initialisatie bij laden ---
     updateStarsVisual(currentRating);
     renderOrUpdateChart(currentRating);

});
 
    </script>

    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.7/dist/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</body>
</html>
